\documentclass[../report.tex]{subfiles}
\def\code#1{\texttt{#1}}
\begin{document}
\onehalfspacing

\pagebreak
\section{Verification}\label{sec:Verif}

In this section I will discuss the security properties used by the Read-Only
section of Verified Boot. 
Later in the section I verify these properties on the Hardware and
Software system that I outlined in Section 2 and Section 3.
The code for Verified Boot is taken from an unmodified vboot\_reference repository provided by Google. 
The Firmware that interacts with this Hardware was created by me, however it was 
modeled after the Firmware originally found in Google's Coreboot repository. 
If Google released the sources for their Hardware, then this testing could be
performed with no modification to the source code. 

Properties in software are checked using CBMC, and Hardware modules are
converted into C using the ILA toolchain.

\subsection{Vboot Properties}

The properties that we will be checking can be separated into 3 categories: array accesses, program flow, and correctness.
The array access property restricts the writeable addresses in memory to valid array boundaries. 
Program flow properties refer to the execution path and function call stack throughout the program.
Correctness properties refer to facts about the code such that, if things were
designed successfully, certain states should not be reached.
Together these categories of properties should encompass each of claims that the system makes about security.

These properties will be specified in Computation Tree Logic (CTL). 
CTL adds temporal distinctions over propositional logic and this allows one to easily describe how a system changes over time.
The boolean connectives in propositional logic are $\lnot$ for NOT, $\land$ for
AND, $\lor$ for OR, and $p \to q$ for $p$ implies $q$.
CTL describes how propositional logic changes through time.
Table~\ref{ctl_syn} describes the CTL syntax.

\begin{table}[!htbp]
    \centering
    \caption{A description of the CTL syntax}\label{ctl_syn}
    \begin{tabular}{|l|l|}
        \hline
        $Xp$ & $p$ is true in the next state\\ \hline
        $Fp$ & $p$ is true eventually\\ \hline
        $Gp$ & $p$ is always true\\ \hline
    \end{tabular}
\end{table}

\subsubsection{Memory Access Locations}

Memory accesses in C are very important because the language allows for arbitrary addresses to be accessed. 
Addressing arrays before their starting address or after their final address is known as a buffer overrun and it is one of the most common security vulnerabilities. 
Buffer overruns allow a program to write or read to arbitrary memory. 
In this program, a buffer overrun could be used to modify the RSA public keys after they have been read in from secure storage, or it could modify the firmware image after it has been verified as secure. 
Such modifications would defeat the security purposes of Vboot and for this reason it is important to prevent the accessing of arrays past the array boundaries.
We can represent correct array accesses through formal specification using the formula below.

\begin{equation}
    G(a \to (i > 0 \land i < size(ptr)))
\end{equation}

In this equation $a$ is any array access, $ptr$ is the start of the array and $i$ is the access offset.
This equation states that for every memory access, the index is greater than 0 so it cannot access memory before the array,  and the index is smaller than the size of the array so memory after the array cannot be accessed.
Luckily, this problem is common enough that CBMC provides checking by default.
However, This equation on its own is not strong enough to provide array access security for verified boot. 
This is because Vboot uses pointer manipulation throughout in order to access structures and data within the Firmware Image. 
Verified boot reads the image in as one contiguous blob and then uses size and offset variables to read more information.
CBMC is not able to detect that this pointer manipulation is an out of bounds array access so this must be manually checked through the use of assertions each time something within the image is accessed.
The pointer manipulation can be expressed formally through the following formula.

\begin{equation}
    G(s \to \text{offset}(\text{struct}) + \text{size}(\text{struct}) <
    \text{size}(\text{img}) \land \text{offset}(\text{struct}) > 0)
\end{equation}

In this equation $s$ is each time a structure is created from a pointer dereference, $struct$ is the structure, and $img$ is the image that it is being pointed to.
The equation states that the offset and size of the struct do not go past the edge of the image and that the offset of the struct does is not negative or before the beginning of the image.

Together these properties state that array accesses must be in bounds and that structure dereferencing must be in bounds of the image that is being referenced.
As these are the two memory referencing techniques that have the potential for overrun, these properties protect the system against overrun attacks.

\subsubsection{Program Flow properties}

There needs to be an ordered constraint on the flow of the program. 
If the program flow is described formally then it will be easy to check that all stages of secure boot were called and in the correct order.
This will catch incorrect programs that skip steps and therefore skip verifying the image, or programs that execute steps out of order and therefore access data that has not been verified yet.
The graph for program flow is shown in Figure~\ref{fig:verif_flow}.
When verifying the flow of Vboot it is necessary to note that there are two firmware images stored in the system, Image A and Image B, and either can be used in the Vboot process. 
It is also necessary to note that Developer mode will skip a step in the verification process, and that this skipped step is a valid part of the Vboot flow.

Let $s_i$ correspond to the ith stage from Figure~\ref{fig:verif_flow} and $s_{ai}$ or $s_{bi}$ correspond to that stage for Image A or Image B respectively.

The equation below states that at any time, we must be in at least one of five stages for either image A or image B.
% Must be in a defined state
\begin{equation}
    G(\bigvee\limits_{i = 0}^{4} s_{ai} \lor s_{bi})
\end{equation}

The equation below states the transitions available for Image A.
Each i\textsuperscript{th} stage can transition either to itself or the following stage.
Image A also has the ability to fail and have a transition immediately to the first stage of verifying Image B.

% Image A transitions to next or to B
\begin{equation}
    G(s_{ai} \to s_{ai} \lor s_{ai+1} \lor s_{b0})
\end{equation}

Now we will describe the state transitions for Image B. 
They are similar to Image A but Image B is always tried secondarily and can only transition to the next stage. 
Image B cannot transition back to verifying Image A or there would be the possibilities of an infinite loop of verifying incorrect images.

% Image B transitions to next
\begin{equation}
    G(s_{bi} \to s_{bi} \lor s_{bi+1})
\end{equation}

The final equation refines the transition for state $s_0$ for Image A and B.
In Figure~\ref{fig:verif_flow} we can see that state $s_0$ can transition to either $s_1$ but it also has a special transition to $s_2$ that is only valid if Developer Mode is enabled.

% State 0 can skip state 1 if in Developer
\begin{equation}
    G(s_0 \to (s_0 \lor s_{1} \lor (M_D \land s_{2})))
\end{equation}

All together these equations fully describe the program flow graph in Figure~\ref{fig:verif_flow}. 
If these hold then steps will not be skipped in the verification process and we can be assured that verification of the image will be attempted in order.

\subsubsection{Correctness properties}

Correctness properties refer to the code itself and help to determine if it has been written correctly.
For Verified Boot, correctness properties are focusing on the correct attestation of the image and attempting to guarantee that an incorrect image cannot be marked as correct and loaded for execution.

The following property states that if the system is not in developer mode and the signature verification fails, then the system will eventually reach the failure state for that image.
It is important that failure and passing is tracked on an image basis because it is possible for Image A to have a bad signature but for Vboot to verify and load a correct Image B.

% Signature is correct when not in Dev mode
\begin{equation} \label{eq:sig_cor}
 \lnot M_d \land \lnot \text{verifySignature(img, rootKey)} \to XF (\text{img.pass} = F)
\end{equation}

The following property states that if the hash of the image data does not match the hash stored in the image, then that specific image will eventually fail.

% Hash is correct always 
\begin{equation} \label{eq:hash_cor}
    \text{hash(img.data)} \neq \text{img.hash} \to XF (\text{img.pass} = F)
\end{equation}

The next property checks against the rollback attack. 
Rollback states that all image versions must be greater than or equal to the last seen image version that is kept in secure storage. 
This property claims that if the image version is lower than what is seen in secure storage, then the image will eventually fail.
Rollback is disabled on Recovery Mode and the property below reflects this fact.

% Version should be greater than previously seen when not in recovery
\begin{equation} \label{eq:rollback}
    \lnot M_r \land (\text{img.version} < \text{prevVersion}) \to XF (\text{img.pass} = F)
\end{equation}

The next property checks that if both images fail, then the Vboot process will fail and the system will eventually reboot into recovery mode.

% If both images fail then boot to recovery 
\begin{equation} \label{eq:both-fail}
    \lnot \text{imgA.pass} \land \lnot \text{imgB.pass} \to XF (\text{pass} = F)
\end{equation}

% TODO: maybe add a Dev wipe property

% TODO: maybe add a hardware return correctly property
% TODO: maybe add that if hash(image) = img.hash -> image = img

In the equations above, img refers to the image to be verified (either Image A or Image B)  and rootKey is Google's public key that has been loaded out of the gbb.
$M_d$ refers to developer mode being active and $M_r$ refers to recovery mode being active.
Img.version is the RW firmware version and prevVersion is the last seen version that is stored in the TPM\@.
These properties will be proved contrapositively, meaning that when verified boot passes we will check that the antecedent is also false.


\subsection{CBMC}

CBMC is a Bounded Model Checking program for the C language that is released by
Carnegie Mellon. 
A Bounded Model Checker is a tool that performs Formal Verification.
Model checking is a way to exhaustively prove whether a given model meets its
specification.
Model checking typically uses propositional logic or temporal logic. 
At its core, CBMC transforms a C program into binary logic and
then uses a SAT solver to check it against the user's specification. 
The specification is user defined, using an API of C functions defined by the
CBMC library. 

% \begin{figure}
%   \centering
%   \includegraphics[width=0.7\linewidth]{CBMC_api.png}
%   \caption{The figure on the left describes the transformation that a C
%   program undergoes to be verified. The right describes the CBMC API.}\label{fig:CBMC_api}
% \end{figure}

The CMBC API is very simple.
The list below describes the 3 functions in the CBMC API.

\begin{itemize}
    \item \code{assert(bool e)} -- takes in a boolean expression and throws
        exception if false.
    \item \code{nondet\_int()} -- returns a non-deterministic integer.
    \item \code{assume(bool e)} -- takes in a boolean expression and forces any
        non-deterministic variables to conform.
\end{itemize}

If the \code{assert()} function throws an exception then CBMC will produce a ``counterexample''.
A counterexample lists the program inputs and steps taken that caused the false
assertion.
The \code{nondet\_int()} function is very helpful to model user input to the Vboot process.
Any data that could be modified by the user could feasibly take any
value, and this is represented cleanly by a non-deterministic integer.
CBMC exhaustively checks user assertions against all possible non-deterministic
integer values.

\subsubsection{Abstractions}

CBMC was able to be successfully run on portions of the verified boot library and provide information on the satisfiability of various assertions.
Running CBMC on the Read-Only section of Vboot with a full Firmware Image is not possible as the program will consume up to 8GB of RAM on my local machine and then be cancelled.
In order to check properties, abstractions needed to be found such that parts of the Vboot flow could be checked at a single time.

The key abstraction used by this thesis is that individual functions are mostly
self contained.
This leads to a natural level abstraction at the function definition.
Each Vboot function returns 0 if successful and an error code if it is not successful.
When a function is abstracted away, it is programmed to return a
non-deterministic value.
If the non-deterministic value is zero (success), then the minimal amount of external changes (if any) should be applied to the larger function.
If the abstracted function returns non-zero (error), then the external changes should be replaced with non-deterministic values.

This method is an over-abstraction of a functions found in the Vboot library.
An over-abstraction contains the full set of states found in the original function, plus additional states that would not be possible.
Because the over-abstraction is a super-set of the original states, any properties that are proved with the over-abstraction will also be proved on every state of the original function.
Therefore any properties proved with abstracted functions will also hold if the real functions were left in place.

Another helpful abstraction is to remove long loops that are present in Verified
Boot.
CMBC performs loop unrolling before it performs any model checking. 
In a program with long loops, the unrolling adds unnecessary complexity and
state to the model and it increases checking time dramatically.
All of Vboots long loops are comparing or copying arrays.
An array compare can be abstracted into a single non-deterministic read on both
arrays.
An array copy can be abstracted into a single non-deterministic write on the
array.
Because the index into the array is non-deterministic in both cases, CBMC will
still perform verification on every acceptable index and find possible
counterexamples.
This abstraction was taken from an earlier thesis that also performed Formal
Verification~\cite{elane}. 

The final abstraction is the creation of a simple memory allocation function so
CBMC will handle pointer manipulation correctly.
Vboot data structures contain offsets to other data structures, not full
pointers. 
Vboot uses offsets because the data structures are loaded from disk and there is
no guarantee that the data will be loaded into a specific address.
(There is however, a guarantee that the data will be loaded contiguously)
The following code shows the simple pointer arithmetic needed for offsets.

\begin{equation} \label{eq:ptr}
\begin{split}
    \code{uint32\_t offset = \&data - \&image;} \\
    \code{void *data\_ptr = \&image + offset;} 
\end{split}
\end{equation}

However, CBMC will not perform pointer arithmetic unless the original pointer
was set to a specific value.
A small memory management function was created to assign pointer values to data
structures so CBMC would perform the correct arithmetic.
In this abstraction memory addresses start at 0x0 and increase as needed.
Memory is never reclaimed.
The idea for this abstraction originated from the work done in modeling memory
by Franjo Ivancic\cite{eff-model-check}.

% \subsubsection{Known CBMC Limitations}
% 
% In order to get CBMC running, certain limitations had to be observed.
% The SAT generator of CBMC unrolls loops before converting the code into a model that can be checked.
% This loop unroller is not able to unroll loops where the upper bound of the loop is data dependant.
% Data Dependant loops need to have their unrolling amount specified by the user.
% However, incorrect unrolling can lead to problems with verification.
% If the unrolling number is too small, then CBMC results may be incorrect, while if the limit is too large the state space may be too large for CMBC to finish in a reasonable time.
% % TODO: may want to remove this bit about Memcpy
% Luckily there was only a single loop of this nature, which existed in the method "Memcpy".
% Using the C implementation of Vboot I was able to determine that Memcpy needed no more than 1050 loop unrollings for the data driven portion of Vboot.

\subsection{Verifying Vboot with CBMC}

In the sections below I run tests on each Vboot function using CBMC\@.
The blue functions are fully software functions that are implemented in the Vboot Library.
The yellow functions connect to the Flash firmware on a real platform, but have been abstracted to return either non-deterministic data for Read-Write information, or hardcoded data for Read-Only information.
The red functions connect to the TPM on a real platform, and are verified on the
ILA TPM for this report.
The purple functions connect to Vboot's software RSA library. 
The green functions connect to the ILA SHA model. 

For each function being verified, the connecting functions are replaced with
abstractions.
These abstractions all follow the idea of an ``over-abstracted'' function.
The abstracted functions can be seen in my Code Repo or the code included in the
Appendix.

Finally, there will be a table describing the results of each CBMC run.
CMBC uses an implementation of a SAT solver known as the MiniSat solver\cite{minisat}.
This solver outputs unSAT if the assertions hold and SAT if they do not. 

\subsubsection{Google's Assertions}

Google has already created a Unit Test Framework for the Verified Boot process.
This framework tests various properties of each function.
Like most Unit Testing Frameworks, the functions are not tested in conjunction
with the rest of the system.
The framework given also stubs out any calls to Hardware, meaning that it 
will not catch any errors across the Hardware Software boundary.
Finally, the framework only checks for the input conditions provided. 
Each function tested has roughly five to fifteen input conditions that are
checked, which is not exhaustive.

Luckily, the framework that Google uses also relies on assertions.
This project was able to hook Google's Unit Test assertions into CBMC
assertions, so Google specific properties can be verified for free along with 
the larger security properties. 

\subsubsection{LoadFirmware}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.6\linewidth]{loadfw.png}
  \caption{The call graph of functions for LoadFirmware}\label{fig:loadfw}
\end{figure}

LoadFirmware is the highest level function that drives Vboot's Firmware Image
verification process.
LoadFirmware is responsible for verifying the Keyblock, Preamble, and Image.
When LoadFirmware returns, it will have set the pass or fail statuses of both Firmware Images, and control will pass to a working Image.

The CBMC test results for this function can be seen in Table~\ref{ldfw_results}. 
Below is an itemized list of what each test is verifying.

\begin{itemize}
 \item  Google unit tests -- this test replaces Google's assertions with CBMC assertions and checks that none of them are violated under any inputs
 \item  rollback test -- tests that under no input conditions will LoadFirmware choose a firmware image with a lower version number (see Property~\ref{eq:rollback}).
 \item  rollback/rec  -- this test is supposed to find a counter-example. It tests for rollback conditions without realizing that rollback is allowed under recovery. 
 \item  hash failure -- tests that it is impossible to verify an image as correct  if hashing the Firmware body (the VbExHashFirmwareBody function) returns an error (see Property~\ref{eq:hash_cor}).
 \item  RSA failure -- tests that is impossible to verify an image as correct if verifying either the Keyblock or Preamble returns an error (see Property~\ref{eq:sig_cor}).
 \item  Array accesses -- check for all possibilities of array bounds errors.
\end{itemize}

\begin{table}[!htbp]
    \centering
    \caption{CBMC tests on the LoadFirmware function}\label{ldfw_results}
    \begin{tabular}{|l|l|l|l|l|l|l|l|}
        \hline
        test name & steps & VCCs & vars  & clauses & time (s) & sat/unsat  \\ \hline \hline
        Google unit\_tests & 6460 & 34 & 1095643 & 24391723 & 67.02 & unsat \\ \hline
        rollback     & 4125 & 1 & 135239 & 1026823 & 4.79 & unsat \\ \hline
        rollback/rec & 4123 & 1 & 135276 & 1026983 & 4.68 & sat \\ \hline
        Hash Failure & 4182 & 2 & 137431 & 1043724 & 4.45 & unsat \\ \hline
        RSA  Failure & 4180 & 2 & 137825 & 1043921 & 4.45 & unsat \\ \hline
        Array Accesses & 4130 & 22 & 102660 & 640715 & 4.51 & unsat \\ \hline
    \end{tabular}
\end{table}

We can see from these tests that CBMC is working successfully and in a reasonable time.
The Google unit test framework is can be put to use with the CBMC framework using minor modifications, and the formal verification can be done in a very reasonable time.

\subsubsection{VbSelectFirmware}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.4\linewidth]{vb_sel_fw.png}
  \caption{The call graph of functions for VbSelectFirmware}\label{fig:vbselfw}
\end{figure}

The VbSelectFirmware function is the wrapper around LoadFirmware.
It is responsible for loading flags in from secure storage and for accessing the TPM\@.
VbSelectFirmware is also responsible for locking the TPM's firmware version before control passes to the firmware image and updating the version if a newer image has been loaded.
This function's final responsibility is to load TPM's PCR0 with the hash of the boot flags.

\begin{itemize}
 \item  TPM locking -- tests that it is not possible for the function to return success if it is unable to lock the TPM
 \item  LoadFirmware -- tests that it is not possible for control to pass to an Image if it is not selected by LoadFirmware
 \item  Array accesses -- check for all possibilities of array bounds errors.
\end{itemize}

\begin{table}[]
    \centering
    \caption{CBMC tests on function VbSelectFirmware}\label{sfw_results}
    \begin{tabular}{|l|l|l|l|l|l|l|l|}
        \hline
        test name & steps & VCCs & vars  & clauses & time (s) & sat/unsat  \\ \hline \hline
        TPM locking & 6 & 5269 & 13513 & 16784 & 0.07 & unsat \\ \hline
        LoadFirmware & 2 & 5264 & 13404 & 16209 & 0.07 & unsat \\ \hline
        Array Accesses & 5257 & 0 & 0 & 0 & 0 &  unsat \\ \hline
    \end{tabular}
\end{table}

\subsection{TPM Properties}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.6\linewidth]{tpm_call_graph}
  \caption{This shows the Vboot call graph for the TPM functionality}\label{fig:tpm_call_graph}
\end{figure}

The Read-Only Firmware is responsible for setting up the TPM and protecting its
sections against the rest of the system that will eventually be loaded.
TPM's responsibilities from Chrome are to securely store the boot state and the
version state.
TPM's storage of the version state allows Vboot to claim that it protects against 
an attacker loading an older, less secure image from Google (Rollback attack).
TPM's storage of the boot state allows Vboot to claim protection against an attacker loading a Google Developer image onto a non-developer machine.

In earlier sections we checked software properties by abstracting the TPM to a simple storage array. 
This allowed us to check the larger rollback and protection properties, although we were assuming that the TPM Firmware functions were working correctly.
Now, we will be using the TPM's Firmware and an abstraction of Hardware to verify correctness of the TPM's Firmware functions.

The main bulk of properties that we will be checking are Correctness and Liveness properties. 
I will also mention how the TPM handles concurrency, and why this does not allow us to check possible properties.

% Rollback Attack

\subsubsection{ILA for Hardware}   

\subsubsection{TPM Properties}   

%TODO get graph of Vboots TPM functions
Some properties are possible to prove using Hardware and Firmware separately.
The first run is showing that each TPM function will only return true if it receives the ``success'' back from the TPM\@.
Once we have this property we can also prove that the TPM will only return the ``success'' value if its operations are completed successfully. 
Combining these two properties can give us an idea of correctness for the system.

However, there are some properties that are much easier to prove with the 
Hardware and Firmware together.
In the third run we have the property that the firmware will always read every available byte from the TPM command fifo.
This property is important to show the Firmware is correct and it relies on interactions between Hardware and Firmware.
The fourth run checks that each function will always return. 
This is important for liveness, because if the Firmware is stuck polling a register forever then the system will not boot.

%TODO: Get TPM CBMC table up and running here

\subsubsection{Verifying TPM with ILA}   

In order to check the TPM, the Vboot firmware had to use the TPM registers and
command flow  described in Section~\ref{tpm_cmd_regs}.
To accomplish this, I built an abstraction of the TPM using the ILA Framework.
The ILA Framework allowed me to program a description of the TPM registers and
command functionality.
This description (referred to as a template), then used the SW TPM library to
verify that the template behaved in the same way as the original TPM. 
The ILA Framework then produced a specification that could be verified with the
original Vboot software.

The TPM ILA code can be seen in the appendix.
The file \code{TPM\_template.py} is the ILA template.
The file \code{TPM\_simulator.py} is a python simulator of the TPM registers that
I used for verification.
The simulator and the template are a formal description of the TPM's registers and command behavior that I outlined previous in Section~\ref{tpm_cmd_regs}. 

\clearpage

\end{document}
