\documentclass[../report.tex]{subfiles}
\begin{document}
\onehalfspacing

\section{Introduction}

Computing systems are becoming larger and more complicated, making security
issues harder to find.
At the same time security problems are having larger impacts on both the personal and societal level.
As the computer industry begins to produce laptops, smart phones, servers, and embedded systems, computer
hardware becomes more diverse and specialized. Diverse hardware increases the
potential for vulnerabilities, and a hardware vulnerability is difficult or
impossible to fix without replacing the device. 

Current industry standard is to use Unit Testing to discover errors in programs. 
Unit Testing is the process of dividing a program up into functional chunks and
verifying each function as a single unit. 
These units are used as ``black boxes'', meaning that they are fed a range
of test inputs, and the behavior is compared against a set of assumptions.
However, Unit Testing has a problem with scaling and with interface interaction.
Inputs for tests scale exponentially, computers can only check a unit against
every possible input if the space of inputs is relatively small. 
Most Unit Tests only test against a few inputs that are thought to be
representative. 
However, this means that there is always the possibility of bugs
on the set of inputs that were not used in testing.
Interface interaction is defined as errors that are a result of a number of
functions interacting together in an undefined way.
These erroneous interactions are not caught by Unit Testing because by
definition only individual units are tested together. 

Formal Verification can be seen as an enhancement to Unit Testing. 
Formal Verification is the act of proving or disproving the correctness of a
function by using mathematical proof techniques. 
This verification requires that the function's correctness is specified in a
series of formal properties.
Once these properties are created, current verification methods 
will produce proofs that the properties hold under all possible inputs.
Unlike Unit Testing, Formal Verification tools look at the code itself to quickly find inputs that would violate a user-defined property. 

Formal Verification guarantees that a program is working correctly. 
This is very helpful for security programs where bugs can release personal information or allow malicious behavior.
Formal Verification of programs are becoming more popular as a formal proof of
a program's correctness provides peace of mind against security bugs.
However, today's security programs are relying both on software programs and
hardware modules working together, and there are no industry standards to
produce verification across this new boundary.

\subsection{The Hardware-Software Boundary}

Originally a computer was a general purpose CPU, and software would
describe how the CPU should perform various tasks.
Today, computer engineers realize that specialized hardware can perform a single
task much more quickly than generalized hardware.
This lead to the creation of a System on a Chip, or SoC. An SoC is the
combination of a CPU with smaller hardware modules that perform specialized
tasks.
The CPU is still the main processing unit, meaning it is responsible for
communicating with each hardware module.
However, the CPU no longer performs all processing in the system.

Hardware modules are taking responsibility away from software.
If software wants to decrypt a message, then it can pass the message to an RSA
hardware module and receive the decrypted message back.
This means that the software does not need to implement a decryption function.
However, the software now needs to know how to communicate with the Hardware
module. This communication between Hardware and Software is known as Firmware.

Firmware is more important now that SoCs are becoming larger and including more
specialized Hardware. 
More computers are including security based hardware, like hashing and encryption/decryption modules.
It is no longer enough to verify software and hardware separately, as the
interactions between the two are an important part in modern security
algorithms.

\subsection{Existing Verification Techniques}

Formal Verification of software is a well researched area and there are several approaches that have been used for formal verification.
Formal Verification is defined as the application of mathematical methods to
prove or disprove the specification of a system~\cite{greenstreet}.
To use Formal Verification, properties of a system have to be specified by the
user. 
Propositional logic is one of the main ways that properties are specified.
For example, a programmer could express that given the fact that a password
check failed, the user should not be allowed to access bank statements.
If $A$ is access and $P$ is correct password, then the following statement
describes the property that, ``If access is given, then the Password is true''.

\begin{equation}
    A \to P
\end{equation}

Propositional Logic is one standard for specifying properties because it is easily
broken down into other formats which are easier to use for verification.
For example, all Propositional Logic statements can be described completely
through Boolean Logic and can then be evaluated using Boolean Satisfiability
Solvers (SAT solvers)~\cite{validating-sat}. SAT Solvers are well-researched but
they have known limitations with scaling and with with the types of systems that
they can describe.
Additional systems have been used to extend the capabilities of SAT solvers, allowing them to describe more complicated properties and systems. 
One system is known as Satisfiability Modulo Theories (SMT), which replaces
Boolean logic elements (eg: AND, OR) with predicates such as inequalities (eg:
Less Than, Greater Than) or uninterpreted functions. 

SMT and SAT Solvers are two tools that are used to do Formal Verification. 
Automated tools exist to transform software programs with
assertions into an SMT solver for formal verification. 
One popular tool that will be used throughout is known as the C Bounded Model Checker (CBMC). 
This tool automatically transforms software into SMT statements to perform
Verification.
More information about Verification tools can be found in
Section~\ref{sec:Verif}. 

%TODO: Hardware Verification here?
%TODO: Firmware Verification here?

% TODO: Change Title
\subsection{Problem Statement}

The trend in modern Computer Architecture is to offload computation to specialized hardware for either speed or power savings~\cite{hardware-accel}.
As this pattern increases the job of verifying functionality becomes more difficult.
Software and Hardware can be verified as separate units but this misses bugs
that exist as a result of the interaction between the two.
Firmware is difficult to verify because it requires both Software and Hardware
working together.

% TODO: Move this to an ILA explanation paragraph 
Tools are needed for allowing Hardware to be used in conjunction with Software for formal verification.
Instruction Level Abstraction (ILA) is a technique that allows Hardware to
be defined as a collection of instructions that are used by Software~\cite{ila}.
This technique claims to allow firmware and hardware to be verified simultaneously and at scale using formal methods.

In order to show the full benefits of formal verification on SoCs, the hardware
and software of the SoC needs to be available for testing.
In the past, small SoCs have been created for the purpose of testing verification.
These SoCs have been built by connecting numerous open source components where the hardware specifications are readily available.
Formal verification has been seen to be successful in analyzing common security protocols such as Secure Boot for small, Open Source SoC designs~\cite{elane}. 
While example SoCs are useful for the first steps in testing verification methods, these methods will be most useful if they can be applied to large designs that already exist and are in use.

In this thesis I will apply Formal Verification tools to Verified Boot in
order to test their effectiveness on a large scale system involving both
Hardware and Software.
Verified Boot is an implementation of a secure bootloader that has been designed by Google to run on their Chromebook laptops.
A bootloader is the first program that runs when a computer is initially turned
on.
A bootloader is responsible for initializing the computer's hardware and
loading the rest of the Operating System.
A secure bootloader is one that checks the code that it is loading for security
properties, and will only load an OS that passes these checks~\cite{secure-bootloader}.
Verified Boot checks that the OS it is loading has been signed by Google and is
unmodified.

Verified Boot is a good candidate for this report because its execution relies
on both Hardware and Software.
As a program, Verified Boot makes security guarantees, like an attacker is not
able to modify the Operating System of a Chromebook. 
A bug in Verified Boot would compromise the security of a personal laptop,
meaning that this is a good candidate for Formal Verification.
Additionally, Google has released both Verified Boot and Chrome OS as Open
Source software, meaning verification can be run directly on industry code.

\subsubsection{Contributions}

The contributions that this thesis makes are the research into the open source firmware project Verified Boot created by Google; the expansion of the formal verification project into an open source software platform; and the evaluation of bounded model checking on verifying security properties of both hardware and software.

% \subsection{Overview}


\end{document}
