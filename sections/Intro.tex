\documentclass[../report.tex]{subfiles}
\begin{document}
\onehalfspacing

\section{Introduction}

The importance of computing in modern society can not be overstated. The
increased responsibilities of computers means that security problems can have
large impacts on both the personal and societal level.  As the computer industry
begins to produce laptops, smart phones, servers, and embedded systems, computer
hardware becomes more diverse and specialized. Diverse hardware increases the
potential for vulnerabilities, and a hardware vulnerability is difficult or
impossible to fix without replacing the device. 

Current industry standard is to use Unit Testing to discover errors in programs. 
Unit Testing is the process of dividing a program up into functional chunks and
verifying each function as a single unit. 
These units are used as ``black boxes'', meaning that they are fed a range
of test inputs, and the behavior is compared against a set of assumptions.
However, Unit Testing has a problem with scaling and with interface interaction.
Inputs for tests scale exponentially, computers can only check a unit against
every possible input if the space of inputs is relatively small. 
Most Unit Tests only test against a few inputs that are thought to be
representative. 
However, this means that there is always the possibility of bugs
on the set of inputs that were not used in testing.
Interface interaction is defined as errors that are a result of a number of
functions interacting together in an undefined way.
These erroneous interactions are not caught by Unit Testing because by
definition only individual units are tested together. 

Formal Verification is an enhancement to Unit Testing. 
Formal Verification is the act of proving or disproving the correctness of a
function by using mathematical proof techniques. 
This verification requires that the function's correctness is specified in a
series of formal properties.
Once these properties are created, there are current verification methods that
will produce proofs that a property holds under all possible inputs.
Unlike Unit Testing, Formal Verification tools look at the code itself to quickly find inputs that would violate a user-defined property. 

Formal guarantees that a program is working correctly is very helpful for
security programs where bugs can release personal information or allow malicious
behavior.
Security programs are becoming more complicated, and bugs are becoming more
harmful.
Formal Verification of programs are becoming more popular as a formal proof of
a program's correctness provides peace of mind against security bugs.
However, today's security programs are relying both on software programs and
hardware modules working together, and there are not industry standards to
produce verification across this new boundary.

\subsection{The Hardware-Software Boundary}

Originally a computer was only a general purpose CPU, and software would
describe how the CPU should perform various tasks.
Today, computer engineers realize that specialized hardware can perform a single
task much more quickly than generalized hardware.
This lead to the creation of a System on a Chip, or SoC. An SoC is the
combination of a CPU with smaller hardware modules that perform specialized
tasks.
The CPU is still the main processing unit, meaning it is responsible for
communicating with each hardware module.

Some hardware modules are taking responsibility away from software.
If software wants to decrypt a message, then it can pass the message to an RSA
hardware module and receive the decrypted message back.
This means that the software does not need to implement a decryption function.
However, the software now needs to know how to communicate with the Hardware
module. This communication between Hardware and Software is known as Firmware.

Firmware is more important now that SoCs are becoming larger and including more
specialized Hardware. 
More computers are including security based hardware, like hashing and encryption/decryption modules.
It is no longer enough to verify software and hardware separately, as the
interactions between the two are an important part in modern security
algorithms.

\subsection{Existing Verification Techniques}

Formal Verification of software is a well researched area and there are several approaches that have been used for formal verification.
Formal Verification is defined as the application of mathematical methods to
prove or disprove the specification of a system~\cite{greenstreet}.
To use Formal Verification, properties of a system have to be specified by the
user. 
Propositional logic is one of the main ways that properties are specified.
For example, a programmer could express that given the fact that a password
check failed, the user should not be allowed to access bank statements.
If $A$ is access and $P$ is correct password, then the following statement
describes the property that access cannot ever be given when the password is not
true.

\begin{equation}
    A \to P
\end{equation}

Propositional Logic is one standard for specifying properties because it is easily
broken down into other formats which are easier to use for verification.
For example, all Propositional Logic statements can be described completely
through Boolean Logic and can then be evaluated using Boolean Satisfiability
Solvers (SAT solvers)~\cite{validating-sat}. SAT Solvers are well-researched but
they have known limitations with scaling and with with the types of systems that
they can describe.
Additional systems have been used to extend the capabilities of SAT solvers, allowing them to describe more complicated properties and systems. 
One system is known as Satisfiability Modulo Theories (SMT), which essentially replaces Boolean logic elements with predicates such as inequalities or uninterpreted functions. 

SMT and SAT Solvers are the tools that are used to do Formal Verification
on Software. Automated tools exist to transform software programs with
assertions into an SMT solver for formal verification. 
One popular tool that will be used throughout the paper is the z3 SMT solver~\cite{z3-smt-solver}.
Another popular tool is the C Bounded Model Checker (CBMC). 
These tools will be described fully in the Verification Section. 

%TODO: Hardware Verification here?
%TODO: Firmware Verification here?

% TODO: Change Title
\subsection{Problem Statement and Proposed Contribution}

The trend in modern Computer Architecture is to offload computation to specialized hardware for either speed or power savings~\cite{hardware-accel}.
As this pattern increases the job of verifying functionality becomes more difficult.
Software and Hardware can be verified as separate units but this misses bugs
that exist as a result of the interaction between the two.
Firmware is difficult to verify because it requires both Software and Hardware
working together.

% TODO: Move this to an ILA explanation paragraph 
Tools are needed for allowing Hardware to be used in conjunction with Software for formal verification.
Instruction Level Abstraction (ILA) is a technique that allows Hardware to
be defined as a collection of instructions that are used by Software~\cite{ila}.
This technique claims to allow firmware and hardware to be verified simultaneously and at scale using formal methods.

In order to show the full benefits of formal verification on SoCs, the hardware
and software of the SoC needs to be available for testing.
In the past, small SoCs have been created for the purpose of testing verification.
These SoCs have been built by connecting numerous open source components where the hardware specifications are readily available.
Formal verification has been seen to be successful in analyzing common security protocols such as Secure Boot for small, Open Source SoC designs~\cite{elane}. 
While example SoCs are useful for the first steps in testing verification methods, these methods will be most useful if they can be applied to large designs that already exist and are in use.

The contributions that this thesis makes are the research into the open source firmware project Verified Boot created by Google; the expansion of the formal verification project into an open source software platform; and the evaluation of bounded model checking on verifying security properties of both hardware and software.

% \subsection{Overview}


\end{document}
