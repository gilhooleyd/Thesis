\documentclass[../report.tex]{subfiles}
\begin{document}
\onehalfspacing

\section{Introduction}

The importance of computing in modern society can not be overstated. The
increased responsibilities of computers means that security problems can have
large impacts on both the personal and societal level.  As the computer industry
begins to produce laptops, smart phones, servers, and embedded systems, computer
hardware becomes more diverse and specialized. Diverse hardware increases the
potential for vulnerabilities, and a hardware vulnerability is difficult or
impossible to fix without replacing the device. 

Current industry standard is to use Unit Testing to discover errors in programs. 
Unit Testing is the process of dividing a program up into functional chunks and
verifying each function as a single unit. 
These units are used as ``black boxes'', meaning that they are fed a range
of test inputs, and the behavior is compared against a set of assumptions.
However, Unit Testing has a problem with scaling and with interface interaction.
Inputs for tests scale exponentially, computers can only check a unit against
every possible input if the space of inputs is relatively small. 
Most Unit Tests only test against a few inputs that are thought to be
representative. 
However, this means that there is always the possibility of bugs
on the set of inputs that were not used in testing.
Interface interaction is defined as errors that are a result of a number of
functions interacting together in an undefined way.
These erroneous interactions are not caught by Unit Testing because by
definition only individual units are tested together. 

Formal Verification is an enhancement to Unit Testing. 
Formal Verification is the act of proving or disproving the correctness of a
function by using mathematical proof techniques. 
This verification requires that the function's correctness is specified in a
series of formal properties.
Once these properties are created, there are current verification methods that
will produce proofs that a property holds under all possible inputs.
Unlike Unit Testing, Formal Verification tools look at the code itself to quickly find inputs that would violate a user-defined property. 

Formal guarantees that a program is working correctly is very helpful for
security programs where bugs can release personal information or allow malicious
behavior.
Security programs are becoming more complicated, and bugs are becoming more
harmful.
Formal Verification of programs are becoming more popular as a formal proof of
a program's correctness provides peace of mind against security bugs.
However, today's security programs are relying both on software programs and
hardware modules working together, and there are not industry standards to
produce verification across this new boundary.

\subsection{The Hardware-Software Boundary}

Originally a computer was only a general purpose CPU, and software would
describe how the CPU should perform various tasks.
Today, computer engineers realize that specialized hardware can perform a single
task much more quickly than generalized hardware.
This lead to the creation of a System on a Chip, or SoC. An SoC is the
combination of a CPU with smaller hardware modules that perform specialized
tasks.
The CPU is still the main processing unit, meaning it is responsible for
communicating with each hardware module.

Some hardware modules are taking responsibility away from software.
If software wants to decrypt a message, then it can pass the message to an RSA
hardware module and receive the decrypted message back.
This means that the software does not need to implement a decryption function.
However, the software now needs to know how to communicate with the Hardware
module. This communication between Hardware and Software is known as Firmware.

Firmware is more important now that SoCs are becoming larger and including more
specialized Hardware. 
More computers are including security based hardware, like hashing and encryption/decryption modules.
It is no longer enough to verify software and hardware separately, as the
interactions between the two are an important part in modern security
algorithms.

\subsection{Previous Work in Verification}

Formal verification of hardware is a well researched area and as such there are several approaches that have been used by industry and academics for formal verification.
Formal verification can be defined as the application of mathematical methods to the specification and verification of systems~\cite{greenstreet}.
Combinational circuits can be described completely through a propositional logic formula, and this formula can be verified using a Boolean Satisfiability (SAT) solver.
Solving SAT problems consists of finding a counterexample, or a subset of of clauses from the Conjunctive Normal Form (CNF) of the formula such that the subset is not satisfiable~\cite{validating-sat}.
The CNF of a formula is the combined AND of a set of clauses where each individual clause is the combined OR of a set of smaller clauses.
SAT solvers are useful for verifying hardware, but they can be extended to verifying properties of any system that can be described through temporal logic.

Additional systems have been used to extend the capabilities of SAT solvers, allowing them to describe more complicated properties and systems. 
One system is known as Satisfiability Modulo Theories (SMT), which essentially replaces Boolean logic elements with predicates such as inequalities or uninterpreted functions. 
Automated tools exist to transform software programs with assertions into an SMT solver for formal verification~\cite{z3-smt-solver}.
Another historically common tool to verify properties is Computation Tree Logic (CTL).
CTL adds temporal distinctions over propositional logic and this allows one to easily describe how a system changes over time.
Through the rest of this paper, software and hardware properties relevant to security will be expressed in CTL\@. 
Once the properties are expressed formally, they will be added to the software programs through assertions and checked using SAT or SMT solvers.

\subsection{Problem Statement}

The trend in modern Computer Architecture is to offload computation to specialized hardware for either speed or power savings~\cite{hardware-accel}.
As this pattern increases the job of verifying functionality  becomes more difficult.
Firmware and hardware can be verified separately but this opens the possibilities of implementation mismatches and missed vulnerabilities.
Verifying firmware and hardware together is necessary but it does not scale well. 
Steps are being taken to create viable tools for abstraction of hardware that help with the scalability issue of formal verification.
Instruction Level Abstraction (ILA) is one such technique that abstracts hardware to functional states that are visible to firmware~\cite{ila}.
This technique claims to allow firmware and hardware to be verified simultaneously and at scale using formal methods.
In order to show the full benefits of formal verification on SoCs, the hardware and software of the SoC needs to be available and conducive to testing.
In the past, small SoCs have been created for the purpose of testing verification.
These SoCs have been built by connecting numerous open source components where the hardware specifications are readily available.
Formal verification has been seen to be successful in analyzing common security protocols such as Secure Boot for small, Open Source SoC designs~\cite{elane}. 
While example SoCs are useful for the first steps in testing verification methods, these methods will be most useful if they can be applied to large designs that already exist and are in use.

The contributions that this thesis makes are the research into the open source firmware project Verified Boot created by Google; the expansion of the formal verification project into an open source software platform; and the evaluation of bounded model checking on verifying security properties of both hardware and software.

% \subsection{Overview}


\end{document}
